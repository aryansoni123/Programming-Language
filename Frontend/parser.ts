import { Stmt, Program, BinaryExpression, Identifier, NumericLiteral, Expression, NullLiteral, VarDeclaration, AssignmentExpression, Property, ObjectLiteral } from "./ast.ts";
import { Tokenize, Token, TokenType} from "./lexer.ts";

// This is the Parser class that will parse the tokens generated by the lexer
// It will convert the tokens into an Abstract Syntax Tree (AST) that can be used by
// the interpreter or compiler to execute the code
// The AST will be a tree structure that represents the code in a way that is easy to understand
export default class Parser {   

    private tokens: Token[] = [];

    private not_eof(): boolean{
        return this.tokens[0].type != TokenType.EOF;
    }
    // This function will take a string of source code and return an AST
    // It will first tokenize the source code and then parse the tokens to create the AST
    // The AST will be a tree structure that represents the code in a way that is easy to understand
    public ProduceAST(sourcecode: string): Program{

        this.tokens = Tokenize(sourcecode);
        const program: Program = {
            kind: "Program",
            body: [],

        }
        // Add an EOF token to the end of the tokens array
        while(this.not_eof()){
            program.body.push(this.parse_Stmt());
        }        
        return program

    }
    // This function will parse a statement and return an AST node
    private parse_Stmt(): Stmt {
        switch (this.at().type) {
            case TokenType.Let:
                //return this.parse_var_declare();
            case TokenType.Const:
                return this.parse_var_declare();

            default:
                return this.parse_Expr();
        }
    }

    private parse_var_declare(): Stmt {
        const isconst = this.eat().type == TokenType.Const;
        const iden = this.expect(
            TokenType.Identifier, 
            "Expected identifier name."
        ).value;

        if (this.at().type == TokenType.SemiColon) {
            this.eat()
            if (isconst){
                throw `Must assign value to ${iden} if using const.`;
            }

            return {
                kind: "VarDeclaration",
                constant: false,
                identifier: iden,
            } as VarDeclaration;
        }

        this.expect(
            TokenType.Assignment,
            "Expected Assignment Operator"
        )

        const declare =  {
            kind: "VarDeclaration",
            constant: isconst,
            identifier: iden,
            value: this.parse_Expr()
        } as VarDeclaration;

        this.expect(
            TokenType.SemiColon,
            `Statement must end with Semicolon`
        );

        return declare;


    }

    // This function will parse an expression and return an AST node
    // It will handle different types of expressions such as binary expressions, identifiers, and numeric literals
    private parse_Expr(): Expression {
        return this.parse_assign_Expr();
    }

    private parse_assign_Expr() : Expression {
        const lhs = this.pares_object_Expr();

        if (this.at().type == TokenType.Assignment) {
            this.eat();
            const rhs = this.parse_adictive_Expr();
            this.expect(TokenType.SemiColon, `Semicolon is Missing.`)
            return {
                kind: "AssignmentExpression",
                assigne: lhs,
                value: rhs
            } as AssignmentExpression;
        }

        return lhs;

    }

    pares_object_Expr() : Expression{
        if (this.at().type !== TokenType.OpenBrace) {
            return this.parse_adictive_Expr();
        }
            
        this.eat(); //eat {
        const properties = new Array<Property>;

        while (this.not_eof() && this.at().type !== TokenType.CloseBrace){
            const key = this.expect(TokenType.Identifier, `Object Literal Key Expected.`).value;

            if(this.at().type == TokenType.Comma){
                this.eat(); //Eat Comma
                properties.push({kind:"Property", key} as Property);
                continue;
            }
            else if(this.at().type ==TokenType.CloseBrace){
                properties.push({kind:"Property", key} as Property);
                continue;
            }

            this.expect(TokenType.Colon, `Missing Colon Following Oject literal.`);
            const value = this.pares_object_Expr()
            properties.push({kind: "Property", key, value } as Property);
            if (this.at().type != TokenType.CloseBrace){
                this.expect(
                    TokenType.Comma,
                    `Expected comma or closing bracket following property.`
                );
            }
        }

        this.expect(TokenType.CloseBrace, `Object Literal missing Closing Braces`);
        return {
            kind: "Object",
            property: properties
        } as ObjectLiteral;
    }

    // This function will parse an additive expression and return an AST node
    private parse_adictive_Expr(): Expression {
        let left = this.parse_multiplicative_Expr();
        // This will handle addition and subtraction
        // It will keep parsing until it reaches a token that is not an addition or subtraction operator
        while (this.at().value == '+' || this.at().value == '-'){
            const operator = this.eat().value
            const right = this.parse_multiplicative_Expr()

            left = {
                kind: "BinaryExpression",
                left,
                right,
                operator
            } as BinaryExpression;
        }
        return left;
    }
    
    // This function will parse a multiplicative expression and return an AST node
    // It will handle multiplication, division, and modulus operations
    private parse_multiplicative_Expr(): Expression {
        let left = this.parse_primary_Expr();

        while (
            this.at().value == '*' || this.at().value == '/' || this.at().value == '%'
        ){
            const operator = this.eat().value
            const right = this.parse_primary_Expr()

            left = {
                kind: "BinaryExpression",
                left,
                right,
                operator
            } as BinaryExpression;
        }
        return left;
    }
    
    // This function will return the next token in the tokens array without removing it
    private at(): Token {
        return this.tokens[0];
    }

    // This function will remove the first token from the tokens array and return it
    private eat(){
        const prev = this.tokens.shift() as Token;
        return prev;
    }

    // This function will expect a token of a certain type and return it
    // If the token is not of the expected type, it will throw an error
    // This is used to ensure that the parser is parsing the correct type of token
    private expect(type : TokenType, error: any): Token {
        const prev = this.eat()
        if (!prev.type || prev.type!==type){
            console.error("Parser Error:\n", error, prev, "- Expecting: ", type);
            Deno.exit(1);
        }
        return prev;
    }

    // This function will parse a primary expression and return an AST node
    // A primary expression can be an identifier, a numeric literal, or a parenthesized expression
    // It will handle the different types of primary expressions and return the appropriate AST node        
    
    private parse_primary_Expr(): Expression {
        const tk = this.tokens[0].type;

        switch (tk) {
            case TokenType.Identifier:
                return {
                    kind: "Identifier",
                    name: this.eat().value
                } as Identifier;

            case TokenType.Number:
                return {
                    kind: "NumericLiteral",
                    value: parseFloat(this.eat().value)
                } as NumericLiteral;

            case TokenType.OpenParen: {
                this.eat();
                const value = this.parse_Expr();
                this.expect(TokenType.CloseParen, "");
                return value;
            }

            case TokenType.Null : {
                this.eat();
                return {
                    kind : "NullLiteral",
                    value: "null"
                } as NullLiteral;
            }

            default:
                console.error("Unexpected Token Found during Parsing ", this.at());
                Deno.exit(1);
        }
    }
}