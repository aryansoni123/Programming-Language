import { Stmt, Program, BinaryExpression, Identifier, NumericLiteral, Expression, NullLiteral } from "./ast.ts";
import { Tokenize, Token, TokenType} from "./lexer.ts";

// This is the Parser class that will parse the tokens generated by the lexer
// It will convert the tokens into an Abstract Syntax Tree (AST) that can be used by
// the interpreter or compiler to execute the code
// The AST will be a tree structure that represents the code in a way that is easy to understand
export default class Parser {   

    private tokens: Token[] = [];

    private not_eof(): boolean{
        return this.tokens[0].type != TokenType.EOF;
    }
    // This function will take a string of source code and return an AST
    // It will first tokenize the source code and then parse the tokens to create the AST
    // The AST will be a tree structure that represents the code in a way that is easy to understand
    public ProduceAST(sourcecode: string): Program{

        this.tokens = Tokenize(sourcecode);
        const program: Program = {
            kind: "Program",
            body: [],

        }
        // Add an EOF token to the end of the tokens array
        while(this.not_eof()){
            program.body.push(this.parse_Stmt());
        }        
        return program

    }
    // This function will parse a statement and return an AST node
    private parse_Stmt(): Stmt {
        //For upcoming Stmt
        return this.parse_Expr();
    }
    // This function will parse an expression and return an AST node
    // It will handle different types of expressions such as binary expressions, identifiers, and numeric literals
    private parse_Expr(): Expression {
        return this.parse_adictive_Expr();
    }

    // This function will parse an additive expression and return an AST node
    private parse_adictive_Expr(): Expression {
        let left = this.parse_multiplicative_Expr();
        // This will handle addition and subtraction
        // It will keep parsing until it reaches a token that is not an addition or subtraction operator
        while (this.at().value == '+' || this.at().value == '-'){
            const operator = this.eat().value
            const right = this.parse_multiplicative_Expr()

            left = {
                kind: "BinaryExpression",
                left,
                right,
                operator
            } as BinaryExpression;
        }
        return left;
    }
    
    // This function will parse a multiplicative expression and return an AST node
    // It will handle multiplication, division, and modulus operations
    private parse_multiplicative_Expr(): Expression {
        let left = this.parse_primary_Expr();

        while (
            this.at().value == '*' || this.at().value == '/' || this.at().value == '%'
        ){
            const operator = this.eat().value
            const right = this.parse_primary_Expr()

            left = {
                kind: "BinaryExpression",
                left,
                right,
                operator
            } as BinaryExpression;
        }
        return left;
    }
    
    // This function will return the next token in the tokens array without removing it
    private at(): Token {
        return this.tokens[0];
    }

    // This function will remove the first token from the tokens array and return it
    private eat(){
        const prev = this.tokens.shift() as Token;
        return prev;
    }

    // This function will expect a token of a certain type and return it
    // If the token is not of the expected type, it will throw an error
    // This is used to ensure that the parser is parsing the correct type of token
    private expect(type : TokenType, error: any) {
        const prev = this.eat()
        if (!prev.type || prev.type!==type){
            console.error("Parser Error:\n", error, prev, "- Expecting: ", type);
            Deno.exit(1);
        }
        return prev;
    }

    // This function will parse a primary expression and return an AST node
    // A primary expression can be an identifier, a numeric literal, or a parenthesized expression
    // It will handle the different types of primary expressions and return the appropriate AST node        
    
    private parse_primary_Expr(): Expression {
        const tk = this.tokens[0].type;

        switch (tk) {
            case TokenType.Identifier:
                return {
                    kind: "Identifier",
                    name: this.eat().value
                } as Identifier;

            case TokenType.Number:
                return {
                    kind: "NumericLiteral",
                    value: parseFloat(this.eat().value)
                } as NumericLiteral;

            case TokenType.OpenParen: {
                this.eat();
                const value = this.parse_Expr();
                this.expect(TokenType.CloseParen, "");
                return value;
            }

            case TokenType.Null : {
                this.eat();
                return {
                    kind : "NullLiteral",
                    value: "null"
                } as NullLiteral;
            }

            default:
                console.error("Unexpected Token Found during Parsing ", this.at());
                Deno.exit(1);
        }
    }
}